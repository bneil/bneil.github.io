<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Benjamin Neil</title><link>/tags/golang/</link><description>Recent content in golang on Benjamin Neil</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 28 May 2021 11:39:43 -0600</lastBuildDate><atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Audit Service</title><link>/post/2021-05-28_rds-audit-service/</link><pubDate>Fri, 28 May 2021 11:39:43 -0600</pubDate><guid>/post/2021-05-28_rds-audit-service/</guid><description>Audit Service or Round 2 Fight Description When I started to think more critically about how interactions would work inside dynamodb for auditing I quickly learned about pain. Lots and lots of pain. Including the fact id probably end up having to use dynamodb streams and couple that with elasticsearch. So im not going to even entertain that idea and am going down the ol trusty sql route.
Creating the database Im still on an older version of terraform, so public shamming for being on 0.</description></item><item><title>Dynamo DB Pages</title><link>/post/dynamodb_pages/</link><pubDate>Tue, 25 May 2021 10:33:49 -0600</pubDate><guid>/post/dynamodb_pages/</guid><description>Dynamo code snippet Recently got burned because we needed to do a recursive paging through dynamo
var listOfThings []Whatever err := store.ScanPages(input, func (page *dynamodb.ScanOutput, lastPage bool) bool { for _, item := range page.Items { var whateva Whatever if val, ok := item[&amp;#34;jval&amp;#34;]; ok { err := json.Unmarshal([]byte(*val.S), &amp;amp;whateva) if err != nil { return true // its like continue } listOfThings = append(listOfThings, whateva) } } return !</description></item></channel></rss>